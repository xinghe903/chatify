非常好！基于你提供的高可用、解耦聊天/推送系统架构设计，我将为你**重新生成一份更贴近生产落地的规范文档**，完全适配你的新要求：

***

# ✅ 优化版：基于 Kafka + gRPC 的高可扩展聊天系统（Kratos 微服务实现）

> **目标**：清晰定义各服务间通信协议，使用 **gRPC 接口（Protobuf）** 和 **Kafka 消息（JSON）**，微服务框架采用 **[Kratos](https://go-kratos.dev/)**。

***

## 一、服务组件与职责（不变）

| 服务 | 职责 |
|------|------|
| `gateway` | 流量入口，处理 HTTP / WebSocket 连接 |
| `access` | 用户连接管理、会话维持、消息收发 |
| `logic` | 业务逻辑：鉴权、消息校验、群聊、计费等 |
| `push` | 推送决策中心：判断在线、执行推送、触发离线存储 |
| `offline` | 离线消息持久化：Redis + DB 回落，支持拉取与确认 |
| `mq` (Kafka) | 所有异步事件通信中介 |

> 🔁 核心原则：**所有同步调用走 gRPC；所有异步事件走 Kafka**

***

## 二、服务间交互方式总览

| 交互类型 | 协议 | 示例场景 |
|--------|------|---------|
| 同步请求/响应 | gRPC (Protobuf) | Access → Logic 鉴权 |
| 异步事件通知 | Kafka (JSON) | Access 发用户上线事件 |
| 广播/分发任务 | Kafka (JSON) | Push 发送推送任务 |

***

## 三、Kafka 主题设计（JSON 消息结构）

> 所有 Kafka 消息为 JSON 格式，Key 可选用于分区路由（如 user\_id），Value 为以下结构。

| Topic | 生产者 | 消费者 | 描述 |
|-------|--------|--------|------|
| `chat.input` | access | logic | 用户输入聊天消息 |
| `push.task` | logic, offline | push | 推送任务（核心） |
| `offline.storage` | push | offline | 存储离线消息 |
| `offline.retrieve` | access | offline | 请求拉取离线消息 |
| `user.online` | access | push, logic, analytics | 用户上线事件 |
| `user.offline` | access | push, logic, analytics | 用户下线事件 |
| `offline.ack` | push | offline | 确认离线消息已送达 |

***

### Kafka 消息结构定义（JSON Schema）

#### 1. `chat.input` —— 用户聊天输入

<pre style="background: none"><code class="language-json" data-language="json" identifier="e673eb8127b24d088f8e0724888826e6-0" index="0" total="14">{
  "message_id": "msg_123",
  "sender_id": "u1001",
  "receiver_id": "u1002",
  "content": "{\"text\": \"Hello\"}",
  "timestamp": 1732608000,
  "message_type": "text",
  "device_info": {
    "platform": "web",
    "ip": "192.168.1.1"
  }
}</code></pre>

#### 2. `push.task` —— 推送任务

<pre style="background: none"><code class="language-json" data-language="json" identifier="e673eb8127b24d088f8e0724888826e6-1" index="1" total="14">{
  "task_id": "task_456",
  "targets": ["u1002", "u1003"],
  "sender": "u1001",
  "content": "{\"text\": \"Hello\"}",
  "message_type": "text",
  "priority": 5,
  "expire_time": 1732694400,
  "metadata": {
    "is_offline_replay": false
  }
}</code></pre>

#### 3. `offline.storage` —— 触发离线存储

<pre style="background: none"><code class="language-json" data-language="json" identifier="e673eb8127b24d088f8e0724888826e6-2" index="2" total="14">{
  "user_id": "u1002",
  "sender": "u1001",
  "content": "{\"text\": \"Hello\"}",
  "timestamp": 1732608000,
  "ttl_seconds": 86400,
  "source_message_id": "msg_123"
}</code></pre>

#### 4. `offline.retrieve` —— 请求离线消息

<pre style="background: none"><code class="language-json" data-language="json" identifier="e673eb8127b24d088f8e0724888826e6-3" index="3" total="14">{
  "user_id": "u1002",
  "since_timestamp": 1732600000,
  "request_id": "req_789"
}</code></pre>

#### 5. `user.online` —— 用户上线事件

<pre style="background: none"><code class="language-json" data-language="json" identifier="e673eb8127b24d088f8e0724888826e6-4" index="4" total="14">{
  "user_id": "u1002",
  "node": "access-node-3",
  "connection_id": "conn_xyz",
  "login_time": 1732608000,
  "protocol": "websocket",
  "client_info": {
    "platform": "iOS",
    "version": "2.1.0"
  }
}</code></pre>

#### 6. `user.offline` —— 用户下线事件

<pre style="background: none"><code class="language-json" data-language="json" identifier="e673eb8127b24d088f8e0724888826e6-5" index="5" total="14">{
  "user_id": "u1002",
  "node": "access-node-3",
  "connection_id": "conn_xyz",
  "logout_time": 1732609000,
  "reason": "network_lost"
}</code></pre>

#### 7. `offline.ack` —— 离线消息送达确认

<pre style="background: none"><code class="language-json" data-language="json" identifier="e673eb8127b24d088f8e0724888826e6-6" index="6" total="14">{
  "user_id": "u1002",
  "message_ids": ["msg_123", "msg_124"],
  "ack_time": 1732609100
}</code></pre>

***

## 四、gRPC 接口定义（Protobuf）

> 使用 Protobuf 定义服务接口，由 Kratos 自动生成 gRPC Server/Client。

### 文件路径建议：

<pre style="background: none"><code identifier="e673eb8127b24d088f8e0724888826e6-7" index="7" total="14">api/
├── access/
│   └── v1/
│       ├── access.proto
├── logic/
│   └── v1/
│       ├── logic.proto
├── push/
│   └── v1/
│       ├── push.proto
└── offline/
    └── v1/
        └── offline.proto</code></pre>

***


package models

// 基础消息结构
type BaseMessage struct {
	MessageID  string      `json:"msg_id"`
	Type       MessageType `json:"type"`        // CHAT, SYSTEM, CONTROL
	Sender     string      `json:"sender"`      // user_id or "system"
	TargetType TargetType  `json:"target_type"` // USER, GROUP, BROADCAST
	Targets    []string    `json:"targets"`     // 接收者列表
	Content    []byte      `json:"content"`     // 消息内容
	Timestamp  int64       `json:"timestamp"`
	Priority   int         `json:"priority"` // 1-10
	RetryCount int         `json:"retry_count"`
	ExpireTime int64       `json:"expire_time"`
}

转为protobuf的消息结构

// 连接信息
type ConnectionInfo struct {
	UserID       string `json:"user_id"`
	AccessNode   string `json:"access_node"`
	ConnectionID string `json:"connection_id"`
	GatewayIP    string `json:"gateway_ip"`
	Protocol     string `json:"protocol"` // WS, TCP
}

// 推送任务消息
type PushTask struct {
	BaseMessage
	TaskId string `json:"task_id"`
}



syntax = "proto3";

package im;

option go_package = "your-project/proto/im";
option java_package = "com.yourproject.im";
option java_outer_classname = "MessageProto";

import "google/protobuf/timestamp.proto";

// 消息类型枚举
enum MessageType {
  MESSAGE_TYPE_UNSPECIFIED = 0;
  CHAT                     = 1;
  SYSTEM                   = 2;
  CONTROL                  = 3;
}

// 目标类型枚举
enum TargetType {
  TARGET_TYPE_UNSPECIFIED = 0;
  USER                    = 1;
  GROUP                   = 2;
  BROADCAST               = 3;
}

// 基础消息结构
message BaseMessage {
  string              msg_id       = 1;     // 消息ID
  MessageType         message_type         = 2;     // 消息类型
  string              sender       = 3;     // 发送者ID 或 "system"
  TargetType          target_type  = 4;     // 目标类型
  repeated string     targets      = 5;     // 接收者列表
  bytes               content      = 6;     // 消息内容（二进制）
  int64               timestamp    = 7;     // 时间戳（单位: 秒 或 毫秒）
  int32               priority     = 8;     // 优先级 1-10
  int32               retry_count  = 9;     // 重试次数
  int64               expire_time  = 10;    // 过期时间戳
}


### 1. `access/v1/access.proto` —— Access 服务对外接口

<pre style="background: none"><code class="language-protobuf" data-language="protobuf" identifier="e673eb8127b24d088f8e0724888826e6-8" index="8" total="14">syntax = "proto3";

package api.access.v1;

option go_package = "api/access/v1;v1";

service AccessService {
  // 用户连接建立后，向 Logic 请求鉴权与初始化
  rpc UserLoginCheck(LoginCheckRequest) returns (LoginCheckResponse);
  
  // 获取用户当前连接状态（供 Push 查询）
  rpc GetUserConnection(GetUserConnectionRequest) returns (GetUserConnectionResponse);
}

message LoginCheckRequest {
  string user_id = 1;
  string token = 2;
  string device_id = 3;
  string ip = 4;
}

message LoginCheckResponse {
  bool allowed = 1;
  string error_msg = 2;
  int32 session_timeout = 3; // seconds
  map&lt;string, string&gt; metadata = 4;
}

message GetUserConnectionRequest {
  string user_id = 1;
}

message GetUserConnectionResponse {
  bool online = 1;
  string access_node = 2;
  string connection_id = 3;
  int64 last_active = 4;
}</code></pre>

***

### 2. `logic/v1/logic.proto` —— Logic 服务对外接口

<pre style="background: none"><code class="language-protobuf" data-language="protobuf" identifier="e673eb8127b24d088f8e0724888826e6-9" index="9" total="14">syntax = "proto3";

package api.logic.v1;

option go_package = "api/logic/v1;v1";

service LogicService {
  // 接收原始消息，返回是否允许发送
  rpc ValidateAndProcessMessage(ChatInputRequest) returns (ChatInputResponse);
  
  // 系统主动推送（公告、通知）
  rpc SendSystemPush(SystemPushRequest) returns (SystemPushResponse);
}

message ChatInputRequest {
  string message_id = 1;
  string sender_id = 2;
  string receiver_id = 3;
  bytes content = 4; // json encoded
  int64 timestamp = 5;
  string message_type = 6;
}

message ChatInputResponse {
  bool success = 1;
  string error_code = 2;
  repeated string expanded_targets = 3; // for group chat
}

message SystemPushRequest {
  repeated string user_ids = 1;
  bytes content = 2;
  string title = 3;
  string category = 4; // announcement, alert, etc.
}

message SystemPushResponse {
  bool success = 1;
}</code></pre>

***

### 3. `push/v1/push.proto` —— Push 服务对外接口

<pre style="background: none"><code class="language-protobuf" data-language="protobuf" identifier="e673eb8127b24d088f8e0724888826e6-10" index="10" total="14">syntax = "proto3";

package api.push.v1;

option go_package = "api/push/v1;v1";

service PushService {
  // 向指定用户推送消息（同步备用通道）
  rpc PushToUser(PushRequest) returns (PushResponse);
  
  // 批量查询用户在线状态
  rpc BatchQueryOnline(BatchQueryRequest) returns (BatchQueryResponse);
}

message PushRequest {
  string task_id = 1;
  string user_id = 2;
  bytes content = 3;
  map&lt;string, string&gt; metadata = 4;
}

message PushResponse {
  enum Status {
    SUCCESS = 0;
    FAILED_OFFLINE = 1;
    FAILED_INVALID_USER = 2;
  }
  Status status = 1;
}

message BatchQueryRequest {
  repeated string user_ids = 1;
}

message BatchQueryResponse {
  message UserStatus {
    string user_id = 1;
    bool online = 2;
    string node = 3;
  }
  repeated UserStatus statuses = 1;
}</code></pre>

***

### 4. `offline/v1/offline.proto` —— Offline 服务对外接口

<pre style="background: none"><code class="language-protobuf" data-language="protobuf" identifier="e673eb8127b24d088f8e0724888826e6-11" index="11" total="14">syntax = "proto3";

package api.offline.v1;

option go_package = "api/offline/v1;v1";

service OfflineService {
  // 主动拉取离线消息（用户上线时）
  rpc RetrieveOfflineMessages(RetrieveRequest) returns (RetrieveResponse);
  
  // 确认一批消息已送达（由 Push 调用）
  rpc AcknowledgeMessages(AckRequest) returns (AckResponse);
}

message RetrieveRequest {
  string user_id = 1;
  int64 since_timestamp = 2;
}

message MessageItem {
  string message_id = 1;
  string sender = 2;
  bytes content = 3;
  int64 timestamp = 4;
}

message RetrieveResponse {
  repeated MessageItem messages = 1;
  bool has_more = 2;
}

message AckRequest {
  string user_id = 1;
  repeated string message_ids = 2;
}

message AckResponse {
  bool success = 1;
}</code></pre>

***

## 五、Kafka 配置建议（适用于 Kafka 集群）

> 基于高吞吐、低延迟、可靠性的聊天系统需求。

| 配置项 | 推荐值 | 说明 |
|--------|--------|------|
| `replication.factor` | 3 | 至少 3 副本，保证数据不丢失 |
| `min.insync.replicas` | 2 | 写入需至少 2 个副本 ACK |
| `acks` (Producer) | `all` | 等待 ISR 全部确认 |
| `enable.idempotence` | true | 开启幂等性，防止重复写入 |
| `delivery.timeout.ms` | 30000 | 控制发送超时 |
| `retries` | 5+ | 启用重试机制 |
| `linger.ms` | 5~10 | 小批量合并提升吞吐 |
| `batch.size` | 16KB ~ 64KB | 批量发送优化 |
| `compression.type` | `lz4` 或 `zstd` | 压缩节省带宽 |
| `retention.ms` | 7天（604800000）| 消息保留时间，便于回溯 |
| `segment.bytes` | 1GB | 分段大小合理 |
| `unclean.leader.election.enable` | `false` | 禁止非ISR节点当选，保一致性 |

> ⚠️ 关键 topic 应设置为 **关键业务级别**，并配置监控告警：
>
> * `push.task`, `offline.storage`, `chat.input`
> * 监控指标：Lag 积压、消费延迟、错误率

***

## 六、Kratos 微服务工程结构建议

<pre style="background: none"><code identifier="e673eb8127b24d088f8e0724888826e6-12" index="12" total="14">services/
├── gateway/
│   ├── service/         # WebSocket 处理
│   └── handler/         # 协议转换
├── access/
│   ├── service/         # 连接管理
│   ├── internal/        # Kafka 消费者
│   └── api/             # Protobuf 编译后代码
├── logic/
│   ├── service/
│   └── consumer/        # 处理 chat.input
├── push/
│   ├── service/
│   ├── connection/      # Redis 维护连接映射
│   └── consumer/        # 消费 push.task
├── offline/
│   ├── service/
│   ├── storage/         # Redis + MySQL 实现
│   └── consumer/        # 处理 retrieve &amp; storage</code></pre>

> 使用 Kratos 的 `Broker` 组件消费 Kafka：

<pre style="background: none"><code class="language-yaml" data-language="yaml" identifier="e673eb8127b24d088f8e0724888826e6-13" index="13" total="14"># kratos.yaml
broker:
  kafka:
    addrs: ["kafka-1:9092", "kafka-2:9092"]
    group_id: "push-group-1"</code></pre>

***

## 七、关键设计决策总结

| 决策点 | 方案 |
|--------|------|
| 在线状态判断 | 由 `Push` 服务通过 Redis 查询连接映射 |
| 离线消息存储触发 | `Push` 推送失败时发布到 `offline.storage` |
| 离线消息删除时机 | `Push` 成功后调用 `Offline.AcknowledgeMessages` 删除 |
| 连接状态共享 | 使用 Redis 存储 `user_conn:{user_id}` → `{node, conn_id}` |
| 消息去重 | `Push` 使用 `message_id + user_id` Redis Set 去重（TTL=5min） |
| 多实例部署 | 所有服务无状态，`Access` 连接亲和由 Gateway 路由 |

***

## 八、后续可扩展方向

✅ 若需，可继续提供：

* **Docker Compose / Kubernetes 部署拓扑图**
* **Redis 数据结构设计（连接映射、离线消息缓存）**
* **MySQL 表结构建议（离线消息持久化）**
* **Kratos 中间件集成（Tracing, Metrics, Auth）**
* **压力测试方案（模拟百万连接）**

***

📌 **总结**：此版本完全满足你的要求：

| 你的要求 | 已实现 ✅ |
|--------|----------|
| 不需要示例代码 | ✔️ 仅保留结构体与接口 |
| gRPC + Protobuf | ✔️ 完整 `.proto` 文件 |
| Kafka + JSON | ✔️ 所有 topic 消息结构 |
| 微服务框架 Kratos | ✔️ 工程结构与配置建议 |
| Kafka 配置建议 | ✔️ 生产级参数推荐 |

如需生成完整的 Protobuf 文件或 `docker-compose.yml`，欢迎继续提问！
