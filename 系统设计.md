以下是根据您的要求重新整理的**聊天/推送系统架构设计文档**，已去除代码、对比、多方案讨论等内容，聚焦于清晰、专业的架构描述，并包含图表说明。

***

# 聊天/推送系统架构设计

## 一、系统概述

本架构设计用于构建一个高可用、可扩展、解耦的实时聊天与消息推送系统。系统支持用户间即时通信、系统通知推送、离线消息存储与补发，适用于大规模在线用户场景。

系统通过消息队列实现服务间完全解耦，各服务职责明确，支持水平扩展与独立部署。

***

## 二、核心服务组件

| 服务 | 职责 |
|------|------|
| **Gateway** | 流量入口，负责接收客户端的 WebSocket 或 HTTP 长连接请求，转发至 Access 层。 |
| **Access** | 管理用户连接生命周期，维护会话状态，接收上行消息并发布到消息队列。 |
| **Logic** | 处理业务逻辑，包括消息鉴权、内容校验、群组消息展开、系统事件生成等。 |
| **Push** | 执行消息推送任务，判断接收方在线状态，决定是否触发离线存储。 |
| **Offline** | 负责离线消息的持久化存储与检索，支持 Redis 缓存 + 数据库回源。 |
| **Message Queue (MQ)** | 所有服务间通信的中枢，实现异步解耦与流量削峰。 |

***

## 三、整体架构图

<pre style="background: none"><code class="language-mermaid" data-language="mermaid" identifier="6a218a828bb44dada8d404237e437db2-0" index="0" total="4">flowchart TD
    subgraph Client
        A[用户A] --&gt; B[用户B]
    end

    subgraph Services
        B --&gt; G[Gateway]
        G --&gt; C[Access]
        C --&gt;|chat_input| MQ[(消息队列)]
        MQ --&gt; L[Logic]
        L --&gt;|push_task| MQ
        MQ --&gt; P[Push]
        P --&gt; C
        P --&gt;|offline_storage| O[Offline]
        O --&gt;|push_task| MQ
        C --&gt;|user_online| MQ
        MQ --&gt; O
    end

    style MQ fill:#f9f,stroke:#333</code></pre>

> **说明**：所有服务通过消息队列通信，无直接调用，实现完全解耦。

***

## 四、核心消息流程

### 1. 用户消息发送流程

<pre style="background: none"><code class="language-mermaid" data-language="mermaid" identifier="6a218a828bb44dada8d404237e437db2-1" index="1" total="4">sequenceDiagram
    participant A as 用户A
    participant G as Gateway
    participant Acc as Access
    participant MQ as 消息队列
    participant L as Logic
    participant P as Push
    participant B as 用户B
    participant O as Offline

    A-&gt;&gt;G: 发送消息
    G-&gt;&gt;Acc: 转发消息
    Acc-&gt;&gt;MQ: 发布 chat_input 事件
    MQ-&gt;&gt;L: Logic 消费
    L-&gt;&gt;MQ: 处理后发布 push_task
    MQ-&gt;&gt;P: Push 消费任务
    alt 用户B在线
        P-&gt;&gt;Acc: 推送消息
        Acc-&gt;&gt;G: 转发至 Gateway
        G-&gt;&gt;B: 投递消息
    else 用户B离线
        P-&gt;&gt;O: 触发离线存储
        O--&gt;&gt;DB: 写入数据库
    end</code></pre>

***

### 2. 用户上线后拉取离线消息

<pre style="background: none"><code class="language-mermaid" data-language="mermaid" identifier="6a218a828bb44dada8d404237e437db2-2" index="2" total="4">sequenceDiagram
    participant U as 用户B
    participant G as Gateway
    participant Acc as Access
    participant MQ as 消息队列
    participant O as Offline
    participant P as Push

    U-&gt;&gt;G: 建立连接
    G-&gt;&gt;Acc: 上线通知
    Acc-&gt;&gt;MQ: 发布 user_online 事件
    MQ-&gt;&gt;O: 触发离线消息检索
    O-&gt;&gt;DB: 查询未读消息
    DB--&gt;&gt;O: 返回消息列表
    O-&gt;&gt;MQ: 批量发布 push_task
    MQ-&gt;&gt;P: Push 消费任务
    P-&gt;&gt;Acc: 推送离线消息
    Acc-&gt;&gt;G: 转发
    G-&gt;&gt;U: 投递历史消息</code></pre>

***

## 五、消息队列主题设计

| 主题（Topic） | 生产者 | 消费者 | 用途 |
|---------------|--------|--------|------|
| `chat_input` | Access | Logic | 用户发送的原始消息 |
| `push_task` | Logic, Offline | Push | 推送任务（核心） |
| `offline_storage` | Push | Offline | 存储离线消息 |
| `offline_retrieve` | Access | Offline | 用户上线触发离线拉取 |
| `user_online` | Access | Offline, Logic, Analytics | 用户上线事件 |
| `offline_ack` | Push | Offline | 确认离线消息已送达（用于安全删除） |

***

## 六、关键设计机制

### 1. 连接状态管理

* 用户连接信息（用户ID、节点、连接ID）统一存储于 **Redis**。
* Access 服务在用户上线时写入 Redis，下线时清除。
* Push 服务通过查询 Redis 判断用户在线状态，避免单点内存依赖。

### 2. 离线消息可靠性保障

* **存储时机**：仅当用户不在线或推送失败时，由 Push 服务触发存储。
* **删除机制**：采用“确认删除”模式，Push 成功投递后发送 `offline_ack`，Offline 服务收到后删除对应记录。
* **防丢失**：启用消息队列持久化与消费确认机制。

### 3. 消息去重与幂等

* 所有消息携带唯一 `message_id`。
* Push 服务使用 Redis 缓存已推送消息 ID，防止重复投递。
* Logic 服务对 `chat_input` 消息做幂等处理。

### 4. 高可用与容错

* 所有服务无状态，可水平扩展。
* 消息队列启用持久化、副本机制（如 Kafka）。
* 消费失败消息进入死信队列（DLQ），支持人工排查。
* 关键队列监控积压与延迟，设置告警。

***

## 七、部署架构示意图

<pre style="background: none"><code class="language-mermaid" data-language="mermaid" identifier="6a218a828bb44dada8d404237e437db2-3" index="3" total="4">graph TD
    Client --&gt; LB[负载均衡]
    LB --&gt; GW1[Gateway]
    LB --&gt; GW2[Gateway]
    GW1 --&gt; ACC1[Access]
    GW2 --&gt; ACC2[Access]
    ACC1 --&gt; MQ
    ACC2 --&gt; MQ
    MQ --&gt; LOGIC[Logic]
    MQ --&gt; PUSH1[Push]
    MQ --&gt; PUSH2[Push]
    MQ --&gt; OFFLINE[Offline]
    PUSH1 --&gt; REDIS[(Redis)]
    PUSH2 --&gt; REDIS
    OFFLINE --&gt; REDIS
    OFFLINE --&gt; DB[(MySQL/PostgreSQL)]
    PUSH1 --&gt; ACC1
    PUSH2 --&gt; ACC2

    style REDIS fill:#ffcc00,stroke:#333
    style DB fill:#66c,stroke:#333
    style MQ fill:#f9f,stroke:#333</code></pre>

> **说明**：
>
> * Redis 存储连接映射、去重缓存、离线消息缓存。
> * 数据库用于离线消息持久化存储。
> * Push 和 Access 多实例部署，通过 Redis 共享状态。

***

## 八、总结

本架构通过以下设计实现高性能、高可用的聊天与推送能力：

* **完全解耦**：所有服务通过消息队列通信，独立演进。
* **职责清晰**：各服务专注单一职责，便于维护与扩展。
* **离线可靠**：基于确认机制的离线消息处理，避免丢失。
* **易于扩展**：支持千万级并发连接，可通过增加节点横向扩容。
* **可观测性强**：关键流程可监控，异常可追溯。

该架构适用于即时通讯、社交应用、通知中心等场景，具备良好的生产落地能力。
